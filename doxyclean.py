#!/usr/bin/python

#	Copyright (c) 2008 Matthew Ball
# 
#	Permission is hereby granted, free of charge, to any person
#	obtaining a copy of this software and associated documentation
#	files (the "Software"), to deal in the Software without
#	restriction, including without limitation the rights to use,
#	copy, modify, merge, publish, distribute, sublicense, and/or sell
#	copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following
#	conditions:
# 
#	The above copyright notice and this permission notice shall be
#	included in all copies or substantial portions of the Software.
#
#	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#	OTHER DEALINGS IN THE SOFTWARE.

import getopt, sys, os, fnmatch, re
from xml.dom import minidom

def usage ():
	sys.stderr.write('''\
	
    Usage: doxyclean.py [-h] [-n projectname] [-i indir] [-o outdir]

    Options:    -h              Converts the cleaned XML to XHTML styled similarly to Apple's documentation
                -n projectname  The name of the project
			    -i indir        Specifies the directory with XML files generated by Doxygen
                -o outdir       Specifies the directory to place the cleaned XML files

	Converts the XML files generated by Doxygen to be more easily-read and more catered to Objective-C.
''')
	sys.exit(1)
	
def _mkdir(newdir):
    if os.path.isdir(newdir):
        pass
    elif os.path.isfile(newdir):
        raise OSError("a file with the same name as the desired " \
                      "dir, '%s', already exists." % newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            _mkdir(head)

        if tail:
            os.mkdir(newdir)

def fileIsDocumented(filePath):
	# Check if the object is documented
	originaldoc = minidom.parse(filePath)
	briefList = originaldoc.getElementsByTagName('briefdescription')
	detailList = originaldoc.getElementsByTagName('detaileddescription')
	
	for briefItem in briefList:
		paraList = briefItem.getElementsByTagName('para')
		if len(paraList) > 0:
			return 1
			
	for detailItem in detailList:
		paraList = detailItem.getElementsByTagName('para')
		if len(paraList) > 0:
			return 1

	return 0

def cleanXML(filePath, outputDirectory):
	_mkdir(outputDirectory)
	
	# Perform the XSL Transform
	fileName = os.path.split(filePath)[1]
	tempPath = outputDirectory + '/' + fileName
	stylesheetPath = sys.path[0] + '/object.xslt'
	os.system('xsltproc -o "' + tempPath + '" "' + stylesheetPath + '" "' + filePath + '"')

	# We will get values from the xml file
	xmldoc = minidom.parse(tempPath)

	# Get the object name
	nameList = xmldoc.getElementsByTagName('name')
	objectName = nameList[0].firstChild.data

	# Get the object type
	objectList = xmldoc.getElementsByTagName('object')
	objectType = objectList[0].attributes['kind'].value

	if objectType == 'class':
		finalPath = outputDirectory + '/Classes'
	elif objectType == 'category':
		finalPath = outputDirectory + '/Categories'

		# Set the filename to something more URL-friendly
		objectName = objectName.replace('(', '_').replace(')', '')
	elif objectType == 'protocol':
		finalPath = outputDirectory + '/Protocols'
		
	_mkdir(finalPath)

	finalPath += '/' + objectName + '.xml'

	os.system('mv "' + tempPath + '" "' + finalPath + '"')

	return (objectName, objectType)
	
def convertToXHTML(filePath, outputDirectory):
	# Get info about the object
	classFile = minidom.parse(filePath)
	# Get the object name
	nameList = classFile.getElementsByTagName('name')
	objectName = nameList[0].firstChild.data
	# Get the object type
	objectList = classFile.getElementsByTagName('object')
	objectType = objectList[0].attributes['kind'].value

	if objectType == 'class':
		outputDirectory += '/Classes'
	elif objectType == 'category':
		outputDirectory += '/Categories'
	elif objectType == 'protocol':
		outputDirectory += '/Protocols'
	_mkdir(outputDirectory)

	outputPath = outputDirectory + '/' + objectName + '.html'

	stylesheetPath = sys.path[0] + '/object2xhtml.xslt'
	os.system('xsltproc -o "' + outputPath + '" "' + stylesheetPath + '" "' + filePath + '"')
	
def createIndexXML(inputDirectory):
	# Create the index xml file
	outputPath = inputDirectory + '/index.xml'
	indexXML = minidom.Document()
	
	projectElement = indexXML.createElement("project")
	projectElement.setAttribute("name", "##PROJECT##")
	indexXML.appendChild(projectElement)
	
	for (path, dirs, files) in os.walk(inputDirectory):
		for fileName in files:
			xmlFile = minidom.parse(path + '/' + fileName)
			
			# Get the object name
			nameList = xmlFile.getElementsByTagName('name')
			objectName = nameList[0].firstChild.data
			
			# Get the objectType
			objectList = xmlFile.getElementsByTagName('object')
			objectType = objectList[0].attributes['kind'].value
			
			# Create an <object> element
			objectElement = indexXML.createElement("object")
			objectElement.setAttribute("kind", objectType)
			projectElement.appendChild(objectElement)
			
			# Create the <name> element
			nameElement = indexXML.createElement("name")
			objectElement.appendChild(nameElement)
			nameText = indexXML.createTextNode(objectName)
			nameElement.appendChild(nameText)
	
	# Write the index xml file
	f = open(outputPath, 'w')
	indexXML.writexml(f, "", "\t", "\n")
	f.close()
	
	return outputPath
	
def convertIndexToXHTML(filePath, outputDirectory):
	# Copy the CSS files over to the new path
	cssPath = sys.path[0] + '/css'
	os.system('cp -R "' + cssPath + '" "' + outputDirectory + '"')
	
	# Create the index html file
	stylesheetPath = sys.path[0] + '/index2xhtml.xslt'
	outputPath = outputDirectory + '/index.html'
	os.system('xsltproc -o "' + outputPath + '" "' + stylesheetPath + '" "' + filePath + '"')
	
def linkify(inputDirectory):
	indexFile = minidom.parse(inputDirectory + '/index.xml')
	documentedObjects = indexFile.getElementsByTagName('name')
	
	# Get each file
	for (path, dirs, files) in os.walk(inputDirectory):
		for fileName in files:
			# Skip the index
			if fileName == 'index.xml':
				break
			
			filePath = path + '/' + fileName
			
			f = open(filePath, "r")
			fileContents = f.read();
			f.close();
			
			# Link to all Foundation and AppKit documentation
			# We don't want links in the name or file
			foundationPattern = "(?<!\\<name\\>|\\<file\\>)([^\\<|^\\>]*)(NSAppleEventDescriptor|NSNetService|NSAppleEventManager|NSNetServiceBrowser|NSAppleScript|NSNotification|NSArchiver|NSNotificationCenter|NSArray|NSNotificationQueue|NSAssertionHandler|NSNull|NSAttributedString|NSNumber|NSAutoreleasePool|NSNumberFormatter|NSBundle|NSObject|NSCachedURLResponse|NSOutputStream|NSCalendarDate|NSPipe|NSCharacterSet|NSPort|NSClassDescription|NSPortCoder|NSCloneCommand|NSPortMessage|NSCloseCommand|NSPortNameServer|NSCoder|NSPositionalSpecifier|NSConditionLock|NSProcessInfo|NSConnection|NSPropertyListSerialization|NSCountCommand|NSPropertySpecifier|NSCountedSet|NSProtocolChecker|NSCreateCommand|NSProxy|NSData|NSQuitCommand|NSDate|NSRandomSpecifier|NSDateFormatter|NSRangeSpecifier|NSDecimalNumber|NSRecursiveLock|NSDecimalNumberHandler|NSRelativeSpecifier|NSDeleteCommand|NSRunLoop|NSDeserializer|NSScanner|NSDictionary|NSScriptClassDescription|NSDirectoryEnumerator|NSScriptCoercionHandler|NSDistantObject|NSScriptCommand|NSDistantObjectRequest|NSScriptCommandDescription|NSDistributedLock|NSScriptExecutionContext|NSDistributedNotificationCenter|NSScriptObjectSpecifier|NSEnumerator|NSScriptSuiteRegistry|NSError|NSScriptWhoseTest|NSException|NSSerializer|NSExistsCommand|NSSet|NSFileHandle|NSSetCommand|NSFileManager|NSSocketPort|NSFormatter|NSSocketPortNameServer|NSGetCommand|NSSortDescriptor|NSHost|NSSpecifierTest|NSHTTPCookie|NSSpellServer|NSHTTPCookieStorage|NSStream|NSHTTPURLResponse|NSString|NSIndexSet|NSTask|NSIndexSpecifier|NSThread|NSInputStream|NSTimer|NSInvocation|NSTimeZone|NSKeyedArchiver|NSUnarchiver|NSKeyedUnarchiver|NSUndoManager|NSLock|NSUniqueIDSpecifier|NSLogicalTest|NSURL|NSMachBootstrapServer|NSURLAuthenticationChallenge|NSMachPort|NSURLCache|NSMessagePort|NSURLConnection|NSMessagePortNameServer|NSURLCredential|NSMethodSignature|NSURLCredentialStorage|NSMiddleSpecifier|NSURLDownload|NSMoveCommand|NSURLHandle|NSMutableArray|NSURLProtectionSpace|NSMutableAttributedString|NSURLProtocol|NSMutableCharacterSet|NSURLRequest|NSMutableData|NSURLResponse|NSMutableDictionary|NSUserDefaults|NSMutableIndexSet|NSValue|NSMutableSet|NSValueTransformer|NSMutableString|NSWhoseSpecifier|NSMutableURLRequest|NSXMLParser|NSNameSpecifier)"
			fileContents = re.sub(foundationPattern, '\\1<ref id="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/\\2_Class/index">\\2</ref>', fileContents)
			
			appKitPattern = "(?<!\\<name\\>|\\<file\\>)([^\\<|^\\>]*)(NSActionCell|NSOpenGLPixelFormat|NSAffineTransform|NSOpenGLView|NSAlert|NSOpenPanel|NSAppleScript Additions|NSOutlineView|NSApplication|NSPageLayout|NSArrayController|NSPanel|NSATSTypesetter|NSParagraphStyle|NSPasteboard|NSBezierPath|NSPDFImageRep|NSBitmapImageRep|NSPICTImageRep|NSBox|NSPopUpButton|NSBrowser|NSPopUpButtonCell|NSBrowserCell|NSPrinter|NSPrintInfo|NSButton|NSPrintOperation|NSButtonCell|NSPrintPanel|NSCachedImageRep|NSProgressIndicator|NSCell|NSQuickDrawView|NSClipView|NSResponder|NSRulerMarker|NSColor|NSRulerView|NSColorList|NSSavePanel|NSColorPanel|NSScreen|NSColorPicker|NSScroller|NSColorWell|NSScrollView|NSComboBox|NSSearchField|NSComboBoxCell|NSSearchFieldCell|NSControl|NSSecureTextField|NSController|NSSecureTextFieldCell|NSCursor|NSSegmentedCell|NSCustomImageRep|NSSegmentedControl|NSDocument|NSShadow|NSDocumentController|NSSimpleHorizontalTypesetter|NSDrawer|NSSlider|NSEPSImageRep|NSSliderCell|NSEvent|NSSound|NSFileWrapper|NSSpeechRecognizer|NSFont|NSSpeechSynthesizer|NSFontDescriptor|NSSpellChecker|NSFontManager|NSSplitView|NSFontPanel|NSStatusBar|NSForm|NSStatusItem|NSFormCell|NSStepper|NSGlyphGenerator|NSStepperCell|NSGlyphInfo|NSGraphicsContext|NSTableColumn|NSHelpManager|NSTableHeaderCell|NSImage|NSTableHeaderView|NSImageCell|NSTableView|NSImageRep|NSTabView|NSImageView|NSTabViewItem|NSInputManager|NSText|NSInputServer|NSTextAttachment|NSLayoutManager|NSTextAttachmentCell|NSMatrix|NSTextContainer|NSMenu|NSTextField|NSMenuItem|NSTextFieldCell|NSMenuItemCell|NSTextStorage|NSMenuView|NSTextTab|NSMovie|NSTextView|NSMovieView|NSToolbar|NSToolbarItem|NSMutableParagraphStyle|NSTypesetter|NSNib|NSNibConnector|NSUserDefaultsController|NSNibControlConnector|NSView|NSNibOutletConnector|NSWindow|NSObjectController|NSWindowController|NSOpenGLContext|NSWorkspace|NSOpenGLPixelBuffer)"
			fileContents = re.sub(appKitPattern, '\\1<ref id="http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/Classes/\\2_Class/index">\\2</ref>', fileContents)
			
		#	f.write(fileContents)
			
			# Get all the paragraphs in the file
			fileXML = minidom.parseString(fileContents)
			fileType = fileXML.getElementsByTagName('object')[0].attributes['kind'].value
			refNodes = fileXML.getElementsByTagName('ref')
		
			# Replace all instances of the current object with a <ref>
			for node in refNodes:
				refName = node.firstChild.data
			
				# Search for the corresponding node in the index
				for documentedObject in documentedObjects:
					# We need to get rid of whitespace (it's a "feature" of minidom)
					objectName = documentedObject.firstChild.data.replace('\n', '').replace('\t', '')
					if objectName == refName:
						objectType = documentedObject.parentNode.attributes['kind'].value
						objectPath = ''
						
						# Determine the proper directory
						if fileType != objectType:
							if objectType == 'class':
								objectPath += '../Classes/'
							elif objectType == 'category':
								objectPath += '../Categories/'
							elif objectType == 'protocol':
								objectPath += '../Protocols/'
						
						objectPath += refName
					
						node.setAttribute('id', objectPath)
						break
					
				# Check if the ref has a "kind" attribute
				if not node.hasAttribute('id'):
					refText = fileXML.createTextNode(refName)
					node.parentNode.replaceChild(refText, node)
				
			# Write the xml file
			f = open(filePath, "w")
			f.write(fileXML.toxml())
		#	f.write(fileContents)
			f.close()
			
def insertProjectName(inputDirectory, projectName):
	# Get each file
	for (path, dirs, files) in os.walk(inputDirectory):
		for fileName in files:
			filePath = path + '/' + fileName
			
			# Replace ##PROJECT## with the project name
			file = open(filePath, "r")
			text = file.read()
			file.close()
			file = open(filePath, "w")
			file.write(text.replace("##PROJECT##", projectName)) 
			file.close()
			
	
if __name__ == '__main__':	
	# If no arguments are given, show the usage message
	if len(sys.argv) == 1:
		usage()
		sys.exit(0)
	
	# Set the default directories
	inputDirectory = os.getcwd()
	outputDirectory = os.getcwd()
	
	shouldConvertToXHTML = 0
	
	projectName = ""
	docsetIdentifier = ""
	
	opts, args = getopt.getopt(sys.argv[1:], 'n:i:o:h')
	for option, value in opts:
		if option[1] == 'i':
			inputDirectory = value
		elif option[1] == 'o':
			outputDirectory = value
		elif option[1] == 'h':
			shouldConvertToXHTML = 1
		elif option[1] == 'n':
			projectName = value
	
	if not os.path.exists(inputDirectory):
		print 'ERROR: Input path does not exist: ' + inputDirectory
		sys.exit(1)
		
	_mkdir(outputDirectory)
		
	xmlOutputDirectory = outputDirectory + "/DoxyCleaned/xml"
	xhtmlOutputDirectory = outputDirectory + '/DoxyCleaned/xhtml'
		
	# Clean up the XML files
	for fileName in os.listdir(inputDirectory):
		if fnmatch.fnmatch(fileName, 'interface_*.xml') or fnmatch.fnmatch(fileName, 'protocol_*.xml'):
			
			shouldConvert = fileIsDocumented(inputDirectory + '/' + fileName)

			if shouldConvert:
				(objectName, objectType) = cleanXML(inputDirectory + '/' + fileName, xmlOutputDirectory)
					
	indexPath = createIndexXML(xmlOutputDirectory)
	
	# Establish inter-file links
	linkify(xmlOutputDirectory)

	if shouldConvertToXHTML:
		# Convert each file
		if (os.path.exists(xmlOutputDirectory + '/Classes')):
			for fileName in os.listdir(xmlOutputDirectory + '/Classes'):
				filePath = xmlOutputDirectory + '/Classes/' + fileName
				convertToXHTML(filePath, xhtmlOutputDirectory)
		if (os.path.exists(xmlOutputDirectory + '/Categories')):	
			for fileName in os.listdir(xmlOutputDirectory + '/Categories'):
				filePath = xmlOutputDirectory + '/Categories/' + fileName
				convertToXHTML(filePath, xhtmlOutputDirectory)
		if (os.path.exists(xmlOutputDirectory + '/Protocols')):	
			for fileName in os.listdir(xmlOutputDirectory + '/Protocols'):
				print fileName
				filePath = xmlOutputDirectory + '/Protocols/' + fileName
				convertToXHTML(filePath, xhtmlOutputDirectory)
		
		convertIndexToXHTML(indexPath, xhtmlOutputDirectory)
	
	# Set the Project Name where necessary
	insertProjectName(outputDirectory + "/DoxyCleaned", projectName)